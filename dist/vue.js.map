{"version":3,"file":"vue.js","sources":["../src/utils.js","../src/observe/array.js","../src/observe/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["/**\r\n * 判断是否为函数\r\n * @param {*} val \r\n * @returns \r\n */\r\nexport function isFunction(val) {\r\n    return typeof val == 'function';\r\n}\r\n\r\n/**\r\n * 判断是否为对象：类型是object，且不能为 null\r\n * @param {*} val \r\n * @returns \r\n */\r\nexport function isObject(val) {\r\n    return typeof val == 'object' && val !== null;\r\n}\r\n\r\n/**\r\n * 判断是否是数组\r\n * @param {*} val \r\n * @returns \r\n */\r\nexport function isArray(val) {\r\n    return Array.isArray(val);\r\n}","/* 出于对性能的考虑，Vue 没有对数组类型的数组使用 Object.defineProperty 进行递归劫持，\r\n而是通过对能够导致原数组变化的 7 个方法进行拦截和重写实现了数据劫持 */\r\n\r\n// 拿到数组的原型方法\r\nlet oldArrayPrototype = Array.prototype;\r\n// 原型继承，将原型链向后移动 arrayMethods.__proto__ == oldArrayPrototype\r\n// Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__\r\nexport let arrayMethods = Object.create(oldArrayPrototype);\r\n\r\n// 重写能够导致原数组变化的七个方法\r\nlet methods = [\r\n    'push',\r\n    'pop',\r\n    'shift',\r\n    'unshift',\r\n    'reverse',\r\n    'sort',\r\n    'splice'\r\n];\r\n\r\n// 在数组自身上进行方法重写，对链上的同名方法进行拦截\r\nmethods.forEach(method => {\r\n    arrayMethods[method] = function() {\r\n        console.log('数组的方法进行重写 method = ' + method);\r\n    }\r\n})","import { isObject, isArray } from '../utils';\r\nimport { arrayMethods } from \"./array\";\r\n\r\n// 核心模块 observe：对数据进行观测\r\nexport function observe(value) {\r\n    // 如果 value 不是对象，就不需要观测，直接 return\r\n    if (!isObject(value)) {\r\n        return;\r\n    }\r\n\r\n    // 观测 value 对象，实现数据响应式\r\n    return new Observer(value);\r\n}\r\n\r\nclass Observer {\r\n    constructor(value) {\r\n        // 分别处理 value 为数组和对象两种情况\r\n        if (isArray(value)) {\r\n            value.__proto__ = arrayMethods; //更改数组的原型方法\r\n        } else {      \r\n            // 如果 value 是对象，遍历对象中的属性，使用 object.defineProperty 重新定义\r\n            this.walk(value); // 循环对象属性\r\n        }\r\n    }\r\n\r\n    // 循环 data 对象，使用 Object.keys 不循环原型方法\r\n    walk(data) {\r\n        Object.keys(data).forEach(key => {\r\n            // 使用 object.defineProperty 重新定义 data 对象中的属性\r\n            defineReactive(data, key, data[key]);\r\n        })\r\n    }\r\n}\r\n\r\n/**\r\n * 给对象Obj，定义属性key，值为value\r\n *  使用Object.defineProperty重新定义data对象中的属性\r\n *  由于Object.defineProperty性能低，所以vue2的性能瓶颈也在这里\r\n * @param {*} obj 需要定义属性的对象\r\n * @param {*} key 给对象定义的属性名\r\n * @param {*} value 给对象定义的属性值\r\n */\r\nfunction defineReactive(obj, key, value) {\r\n    // 递归实现深层观测\r\n    observe(value);\r\n\r\n    Object.defineProperty(obj, key, {\r\n        get() {\r\n            return value;\r\n        },\r\n        set(newValue) {\r\n            if (newValue === value) return;\r\n            value = newValue;\r\n        }\r\n    })\r\n}","import { observe } from './observe';\r\nimport { isFunction } from './utils';\r\n\r\n// 状态的初始化\r\n// 集中进行数据的初始化处理：initState 方法\r\nexport function initState(vm) {\r\n    // 获取 options：_init 中已 options 挂载到 vm.$options\r\n    const opts = vm.$options;\r\n\r\n    if (opts.data) {\r\n        initData(vm);  // data 数据的初始化\r\n    }\r\n\r\n    // props 数据的初始化\r\n    // watch 数据的初始化\r\n    // computed 数据的初始化\r\n}\r\n\r\nfunction initData(vm) {\r\n    let data = vm.$options.data; // 拿到 vue 初始化时，用户传入的 data 数据\r\n\r\n    // data 可能是函数或对象\r\n    //  如果 data 是函数，则需要让 data 函数执行，拿到它返回的对象\r\n    //  如果 data 是对象，不做处理\r\n    // data 执行时，绑定 this 为 vm\r\n    data = isFunction(data) ? data.call(vm) : data;\r\n\r\n    observe(data); // 使用 observe 实现 data 数据的响应式\r\n\r\n    console.log(data);\r\n    data.arr.push(22);\r\n}","import { initState } from \"./state\";\r\n\r\n// 原型方法 _init 模块化处理\r\nexport function initMixin(Vue) {\r\n    // 在 Vue 原型上扩展一个原型方法 _init,进行 vue 初始化\r\n    Vue.prototype._init = function (options) {\r\n        // console.log(options);\r\n        const vm = this; // this 指向当前 vue 实例\r\n        vm.$options = options; // 将 Vue 实例化时用户传入的 options 暴露到 vm 实例上\r\n\r\n        // new Vue 时，传入 options 选项，包含 el 和 data\r\n        initState(vm); // 状态的初始化\r\n\r\n        if (vm.$options.el) {\r\n            console.log(\"有el,需要挂载\");\r\n        }\r\n    }\r\n}","import { initMixin } from \"./init\";\r\n\r\n/* Vue 中所有功能都是通过原型扩展方式添加的\r\n@Param {*} options  new Vue 时传入的 options 配置对象 */\r\nfunction Vue(options) {\r\n    this._init(options); // 调用 Vue 原型上 _init 方法\r\n}\r\n\r\n// 调用 initMixin 进行 Vue 初始化操作\r\ninitMixin(Vue);\r\n\r\nexport default Vue;"],"names":["isFunction","val","isObject","isArray","Array","oldArrayPrototype","prototype","arrayMethods","Object","create","methods","forEach","method","console","log","observe","value","Observer","constructor","__proto__","walk","data","keys","key","defineReactive","obj","defineProperty","get","set","newValue","initState","vm","opts","$options","initData","call","arr","push","initMixin","Vue","_init","options","el"],"mappings":"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"}